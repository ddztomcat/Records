## 写在前面
大家都听说过execution context（执行上下文或执行环境），在操作系统中也有类似的上下文概念，它指得是存储在各寄存器中的中间数据，还有context switchs（上下文切换）等概念，那js中的context跟os中的context相比，是不是也有异曲同工之妙呐？

>看个题目，试想下浏览器是执行这段代码？
```js
let a = 1
var b = 2
function jad() {
    var a = 2
    jdzw()
}
function jdzw() {
    console.log(a, b)
}
jad() //1 2
```
## 执行上下文
#### 相关的几个关键词

+ 执行栈（Execution Stack/Calling Stack）
+ 变量提升（Hoisting）
+ 作用域链（Scope）
+ 闭包（Closure）
+ 词法环境（LexicalEnvironment）
+ 变量环境（VariableEnvironment）

<strong>首先要明确的是执行上下文跟作用域链是两个不同的概念</strong>

定义：执行上下文是一个"环境"的抽象概念，在这个“环境”中Javascript代码被分析和执行。任何代码在JavaScript中运行时，都是在执行上下文中运行的。
#### 上下文的类型
1. **全局执行上下文（global execution context）**
这就是我们通常所说的全局环境，这里所能访问的变量都挂载到一个global object上，在浏览器中就是window对象，在node中就是global对象。<strong>程序在执行时只会有一个全局上下文存在</strong>
2. **函数执行上下文（function execution context）**
每一个函数在调用执行时都会创建一个上下文，当函数上下文被创建时，按照执行顺序会被推到执行栈中（具体过程稍后会讲），这也就意味这程序执行过程中会有多个函数上下文，并且还伴随着上下文的销毁。
3. **eval函数执行上下文**
代码在eval函数执行时也会有自己的上下文，开发过程中并不常涉及到，仅作为类别了解。
## 执行栈
简单理解就是遵循LIFO的栈结构，结合图解和动图感受一下上述函数的执行过程，目前我们只需要关注call stack 和 scope下的内容即可
![](./images/1.jpg)
1. 当浏览器加载完成代码后，会首先创建global execution context推到栈中，
2. 当执行jad()时，会创建该函数的执行上下文，推到stack顶部；
3. 当遇到jdzw()时同样也是新建函数上下文，推到stack顶。
4. 每一个函数执行完后，会依次pop出自己的上下文，最终只会保留global 上下文
## 上下文的创建
上图中我们发现它scope中存在local和global这两个变量，local中保存有当前函数可以访问到的变量名，而global其实就是window，保存全局的一些变量，这其实就是一个简单的作用域链，那么这个scope是怎样创建出来的呐？

<strong>具体过程涉及到上下文的两个阶段：创建阶段和执行阶段</strong>
### 创建阶段
在这期间会创建LexicalEnvironment和VariableEnvironment两部分，伪代码表示
```js
ExecutionContext = {
  LexicalEnvironment: {},
  VariableEnvironment: {},
}
```
#### LexicalEnvironment是什么？

简单理解为是标识符-变量的映射（identifier-variable mapping）标识符指的是函数或变量的名称，变量指得是真正的引用对象或基本类型数据。它包含三个结构：
1. environment record（环境记录）
2. outer environment（外部的环境）
3. this（this的绑定）


#### Environment Record
对于Environment Record，又分为Declarative environment record（声明式环境记录）和Object environment record（对象式环境记录）两种，

<strong>声明式环境记录主要用在函数上下文中，包含变量、函数和arguments对象；相反对象式环境记录则用于全局上下文中，主要用于记录全局的对象，函数和变量</strong>

#### outer environment
outer environment指向外部的LexicalEnvironment，这样可以获取到外部的数据。全局上下文的outer总是指向null

#### this
this绑定依赖于函数的执行方式，全局环境中this指向global object。[关于this的理解推荐查看之前的文章]()

#### VariableEnvironment又是什么？
它也是一种LexicalEnvironment，只不过是用来保存用var声明的变量。

举个🌰
```js
let a = 1
var b = 2
var h
function jad() {
    var c = 2
    let d = 3
    return c + d
}
h = jad(1，2)
```
上述代码的全局上线文创建过程如下：
```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      a: <uninitialized>, // let声明在创建时期uninitialized
      jad: <function>
    }
    outer: <null>,
    this: <global object>
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      b: undefined, // var 声明undefined
      h: undefined
    }
    outer: <null>,
    this: <global object>
  }
}
```
jad执行时，函数上下文的创建过程如下
```js
JadFunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative", // 函数上下文的环境记录Declarative
      d: <uninitialized>,
      Arguments: {0: 1, 1: 2, length: 2
    }
    outer: <GlobalExectionContext>,
    this: <global>
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      c: undefined,
    }
    outer: <GlobalExectionContext>,
    this: <global>
  }
}
```
可以观察到let声明的变量在创建过程中是未初始化的，而var声明的变量是undefined，这也就是为什么在var之前访问变量会输出undefined，而let会报错。
>但如果let 声明的之后访问，虽然没赋值，引擎也会默认undefined
### 执行阶段
当进入执行阶段，上述代码的全局上下文会更新如下：
```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      a: 1, // 执行完 a = 1
      jad: <function>
    }
    outer: <null>,
    this: <global object>
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      b: 2, // 执行完 b =2
      h: undefined
    }
    outer: <null>,
    this: <global object>
  }
}
```
jad执行时，函数上下文的更新如下
```js
JadFunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative", // 函数上下文的环境记录Declarative
      d: 3, // 执行let d = 3
      Arguments: {0: 1, 1: 2, length: 2
    }
    outer: <GlobalExectionContext>,
    this: <global>
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      c: 2, // 执行 var c = 2
    }
    outer: <GlobalExectionContext>,
    this: <global>
  }
}
```
当`jad`函数执行完后，将返回值更新到`h`。
## 作用域链

### 变量提升 函数 表达式
### 闭包
### this绑定
### 延长作用域