#### arguments 不能在箭头函数中访问
```js
function getDebounce(fn, time) {
      let th = null
      return (...res) => {
        clearTimeout(th)
        th = setTimeout(() => {
          fn.call(this, ...res)
        }, time)
      }
}

function getDebounce(fn, time) {
      let th = null
      return function() {
        clearTimeout(th)
        th = setTimeout(function() {
          fn.call(this, ...arguments)
        }, time)
      }
},

```

#### last-child last-of-type

先匹配到该选择器选中的dom类型的元素，再进一步比较该类型dom元素是否符合要求
```css 
//
```
#### 柯里化
```js
function curry(fun) {
  let args = Array.prototype.slice.call(argements, 1)
  let _func = function() {
    if(argements.length === 0) {
      return fun.apply(this, args)
    }else {
      Array.prototype.push.apply(args, argements)
      return _func
    }
  }
  return _func
}
```
#### 利用apply简单实现bind
```js
Function.prototype.bind = function(context) {
  let _arg = Array.prototype.slice.apply(argements, 1)
  let _this = this
  return function() {
    Array.prototype.push.apply(_arg, Array.prototype.slice.apply(argements))
    _this.apply(context, _args)
  }
}
```
#### new 工作本质
```js
let b = new a()
// 相当于
let t = {}
let b = a.call(t)
b = b || t
```
#### redux compose js 解释
```js
 // 传入一个函数数组，返回一个函数 该函数是数组从右往左的compose
 // 该过程跟某一特定生产线类似，都是对同一产品的依次加工
 function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }
  // 执行到此处 length必然大于等于2 
  // 才能确保reduce函数正确执行 因为reduce 函数在数组为空时 必须穿一个默认值，否则会报错
  // 首先明确reduce的返回值 一定跟该数组中任意一项 同种数据结构
  // 比如 a.reduce((b, c) => b + c, 1) 该返回值 正常一定是 整数
  // 所以 return 语句返回值的一定是个函数
  // 如何达到 从右往左 执行的呐？
  // 关键在于 a(b(...args)) 倘若变成 b(a(...args))则是 从左往右
  return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```