#### arguments 不能在箭头函数中访问
```js
function getDebounce(fn, time) {
      let th = null
      return (...res) => {
        clearTimeout(th)
        th = setTimeout(() => {
          fn.call(this, ...res)
        }, time)
      }
}

function getDebounce(fn, time) {
      let th = null
      return function() {
        clearTimeout(th)
        th = setTimeout(function() {
          fn.call(this, ...arguments)
        }, time)
      }
},

```

#### last-child last-of-type

先匹配到该选择器选中的dom类型的元素，再进一步比较该类型dom元素是否符合要求
```css 
//
```
#### 柯里化
```js
function curry(fun) {
  let args = Array.prototype.slice.call(argements, 1)
  let _func = function() {
    if(argements.length === 0) {
      return fun.apply(this, args)
    }else {
      Array.prototype.push.apply(args, argements)
      return _func
    }
  }
  return _func
}
```
#### 利用apply简单实现bind
```js
Function.prototype.bind = function(context) {
  let _arg = Array.prototype.slice.apply(argements, 1)
  let _this = this
  return function() {
    Array.prototype.push.apply(_arg, Array.prototype.slice.apply(argements))
    _this.apply(context, _args)
  }
}
```
#### new 工作本质
```js
let b = new a()
// 相当于
let t = {}
let b = a.call(t)
b = b || t
```
#### redux compose js 解释
```js
 // 传入一个函数数组，返回一个函数 该函数是数组从右往左的compose
 // 该过程跟某一特定生产线类似，都是对同一产品的依次加工
 function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }
  // 执行到此处 length必然大于等于2 
  // 才能确保reduce函数正确执行 因为reduce 函数在数组为空时 必须穿一个默认值，否则会报错
  // 首先明确reduce的返回值 一定跟该数组中任意一项 同种数据结构
  // 比如 a.reduce((b, c) => b + c, 1) 该返回值 正常一定是 整数
  // 所以 return 语句返回值的一定是个函数
  // 如何达到 从右往左 执行的呐？
  // 关键在于 a(b(...args)) 倘若变成 b(a(...args))则是 从左往右
  return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```
#### 扁平化数组函数
```js
function flat(arr) {
  let a = []
  for(let item of arr) {
    if(Array.isArray(item)) {
      a.push(...flat(item))
    }else {
      a.push(item)
    }
  }
  retu
```
#### 排序
```js
function Qsort(arr, start, end) {//约定start end 总不会数组越界
  function solve(start, end) {// 该函数的作用就是 返回一个数组下标，同时数组中该下标的左边一定不大于它，右边一定不小于它
    let k = arr[start] // 我们选定arr[start] 作为参考值 为什么要选start为参考值？这是我个人习惯，参考值可以任意选择
    while (start < end) {// 为什么是< 不是 <= ? 我们需要循环终止时 一定是 start === end 
      while (arr[end] >= k && start < end) end-- //为什么是 >= k？快排并不是一个稳定的排序，所以我们找到一个小于k的值，并将它放到最左端就可以了
      arr[start] = arr[end]// 会不会把原先start位置的值 覆盖丢失掉？不会因为我们的值已经被保存在k或arr[end]中了
      while (arr[start] <= k && start < end) start++//找到一个大于k的值
      arr[end] = arr[start]// 并将它放到最左端，此时start的值 被保存在arr[end]不存在覆盖丢失
    }
    arr[start] = k // arr[end] = k 也是一样的，因为此处start === end 这里只需要将参考值放到它应该在的位置
    return start
  }
  if (start < end) {
    let m = solve(start, end)
    Qsort(arr, 0, m - 1)//将数组0 到 m - 1排序
    Qsort(arr, m + 1, end)//将数组m 到 end排序
  }
}

function bubbleSort(arr) {
  let start = 0, end = arr.length
  for(let i = end - 1; i >= 0; i--) {
    for(let j = start; j < i; j++) { // 将0 - i 中最大的值放到i中 就像气泡往上冒一样
      if(arr[j] > arr[j + 1]) {// 比较j j+1 保证j+1 不小于 j
        let a = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = a
      }
    }
  }
}
function selectSort(arr) {
  let start = 0, end = arr.length
  for(let i = start; i < end; i++) {
    let min = arr[i], key = i
    for(let j = i; j < end; j++) { // 选择 i - end中最小的值 将其放到第i位置上 也就是第i小的值放到i位置上
      if(min > arr[j]) {
        min = arr[j]
        key = j
      }
    }
    arr[key] = arr[i]
    arr[i] = min 
  }
}
```
#### css sticky
可以理解为距离top/left/right/bottom至少 n，否则由relative 变成 fixed
1. 须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。
    + 并且 top 和 bottom 同时设置时，top 生效的优先级高，left 和 right 同时设置时，left 的优先级高。
2. 设定为 position:sticky 元素的任意父节点的 overflow 属性必须是 visible，否则 position:sticky 不会生效。这里需要解释一下：
    + 如果 position:sticky 元素的任意父节点定位设置为 overflow:hidden，则父容器无法进行滚动，所以 position:sticky 元素也不会有滚动然后固定的情况。
    + 如果 position:sticky 元素的任意父节点定位设置为 position:relative | absolute | fixed，则元素相对父元素进行定位，而不会相对 viewprot 定位。
3. 达到设定的阀值。这个还算好理解，也就是设定了 position:sticky 的元素表现为 relative 还是 fixed 是根据元素是否达到设定了的阈值决定的。
#### bfc
+ 根元素
+ float属性不为none
+ position为absolute或fixed
+ display为inline-block, table-cell, table-caption, flex, inline-flex
+ overflow不为visible
#### NodeList HTMLCollection Array
> myNodeList --> NodeList.prototype --> Object.prototype --> null

> myArray --> Array.prototype --> Object.prototype --> null
+ NodeList 对象是一个节点的集合，是由 Node.childNodes 和 document.querySelectorAll 返回的.
  + 在一些情况下，NodeList 对象是一个实时集合，也就是说，如果文档中的节点树发生变化，则已经存在的实时 NodeList 对象也会随之变化。例如，Node.childNodes 是实时的.在其他情况下，NodeList 是一个静态集合，也就意味着随后对文档对象模型的任何改动都不会影响集合的内容。比如document.querySelectorAll 就会返回一个静态的 NodeList。
    ```js
    var parent = document.getElementById('parent');
    var child_nodes = parent.childNodes;
    console.log(child_nodes.length); // 我们假设结果会是“2”
    parent.appendChild(document.createElement('div'));
    console.log(child_nodes.length); // 但此时的输出是“3”
    ```
+ HTML DOM 中的 HTMLCollection 是即时更新的（live）；当其所包含的文档结构发生改变时，它会自动更新。
    ```js
    var elem1, elem2;

    // document.forms 是一个 HTMLCollection

    elem1 = document.forms[0];
    elem2 = document.forms.item(0);

    alert(elem1 === elem2); // 显示 "true"

    elem1 = document.forms["myForm"];
    elem2 = document.forms.namedItem("myForm");

    alert(elem1 === elem2); // 显示 "true"
    ```