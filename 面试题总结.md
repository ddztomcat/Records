#### arguments 不能在箭头函数中访问
```js
function getDebounce(fn, time) {
      let th = null
      return (...res) => {
        clearTimeout(th)
        th = setTimeout(() => {
          fn.call(this, ...res)
        }, time)
      }
}

function getDebounce(fn, time) {
      let th = null
      return function() {
        clearTimeout(th)
        th = setTimeout(function() {
          fn.call(this, ...arguments)
        }, time)
      }
},

```

#### last-child last-of-type

先匹配到该选择器选中的dom类型的元素，再进一步比较该类型dom元素是否符合要求
```css 
//
```
#### 柯里化
```js
function curry(fun) {
  let args = Array.prototype.slice.call(argements, 1)
  let _func = function() {
    if(argements.length === 0) {
      return fun.apply(this, args)
    }else {
      Array.prototype.push.apply(args, argements)
      return _func
    }
  }
  return _func
}
```
#### 利用apply简单实现bind
```js
Function.prototype.bind = function(context) {
  let _arg = Array.prototype.slice.apply(argements, 1)
  let _this = this
  return function() {
    Array.prototype.push.apply(_arg, Array.prototype.slice.apply(argements))
    _this.apply(context, _args)
  }
}
```
#### new 工作本质
```js
let b = new a()
// 相当于
let t = {}
let b = a.call(t)
b = b || t
```
#### redux compose js 解释
```js
 // 传入一个函数数组，返回一个函数 该函数是数组从右往左的compose
 // 该过程跟某一特定生产线类似，都是对同一产品的依次加工
 function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }
  // 执行到此处 length必然大于等于2 
  // 才能确保reduce函数正确执行 因为reduce 函数在数组为空时 必须穿一个默认值，否则会报错
  // 首先明确reduce的返回值 一定跟该数组中任意一项 同种数据结构
  // 比如 a.reduce((b, c) => b + c, 1) 该返回值 正常一定是 整数
  // 所以 return 语句返回值的一定是个函数
  // 如何达到 从右往左 执行的呐？
  // 关键在于 a(b(...args)) 倘若变成 b(a(...args))则是 从左往右
  return funcs.reduce((a, b) => (...args) => a(b(...args)))
}
```
#### 扁平化数组函数
```js
function flat(arr) {
  let a = []
  for(let item of arr) {
    if(Array.isArray(item)) {
      a.push(...flat(item))
    }else {
      a.push(item)
    }
  }
  retu
```
#### 排序
```js
function Qsort(arr, start, end) {//约定start end 总不会数组越界
  function solve(start, end) {// 该函数的作用就是 返回一个数组下标，同时数组中该下标的左边一定不大于它，右边一定不小于它
    let k = arr[start] // 我们选定arr[start] 作为参考值 为什么要选start为参考值？这是我个人习惯，参考值可以任意选择
    while (start < end) {// 为什么是< 不是 <= ? 我们需要循环终止时 一定是 start === end 
      while (arr[end] >= k && start < end) end-- //为什么是 >= k？快排并不是一个稳定的排序，所以我们找到一个小于k的值，并将它放到最左端就可以了
      arr[start] = arr[end]// 会不会把原先start位置的值 覆盖丢失掉？不会因为我们的值已经被保存在k或arr[end]中了
      while (arr[start] <= k && start < end) start++//找到一个大于k的值
      arr[end] = arr[start]// 并将它放到最左端，此时start的值 被保存在arr[end]不存在覆盖丢失
    }
    arr[start] = k // arr[end] = k 也是一样的，因为此处start === end 这里只需要将参考值放到它应该在的位置
    return start
  }
  if (start < end) {
    let m = solve(start, end)
    Qsort(arr, 0, m - 1)//将数组0 到 m - 1排序
    Qsort(arr, m + 1, end)//将数组m 到 end排序
  }
}

function bubbleSort(arr) {
  let start = 0, end = arr.length
  for(let i = end - 1; i >= 0; i--) {
    for(let j = start; j < i; j++) { // 将0 - i 中最大的值放到i中 就像气泡往上冒一样
      if(arr[j] > arr[j + 1]) {// 比较j j+1 保证j+1 不小于 j
        let a = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = a
      }
    }
  }
}
function selectSort(arr) {
  let start = 0, end = arr.length
  for(let i = start; i < end; i++) {
    let min = arr[i], key = i
    for(let j = i; j < end; j++) { // 选择 i - end中最小的值 将其放到第i位置上 也就是第i小的值放到i位置上
      if(min > arr[j]) {
        min = arr[j]
        key = j
      }
    }
    arr[key] = arr[i]
    arr[i] = min 
  }
}
```