## 解构赋值的骚操作

#### 交换a,b
```javascript
//交换a，b的值
//普通做法
let t = a
a = b
b = t
//解构
[a, b] = [b, a]
```

#### 深入理解
+ 扩展运算符的解构赋值只能包含`对象自身的可枚举属性`
+ 对象的扩展运算符（...）用于取出参数`对象自身的所有可遍历属性`，拷贝到当前对象之中。
+ ... 用在 = 语句 左边起到收敛 右边发散

```javascript
const o = Object.create({ x: 1, y: 2 });
o.z = 3;

let { x, ...newObj } = o;
let { y, z } = newObj;
x // 1
y // undefined
z // 3
```
#### extends
```js
class B extends A {
}
// 等同于
B.__proto__ = A
B.prototype.__proto__ = A.prototype
// 如何理解？ B 作为对象它需要有__protp__属性，继承A的静态属性
// B 作为函数 它需要有prototype属性，要确保他的实例 也属于A类型  

Object.setPrototypeOf = function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
```
